


ARM Macro Assembler    Page 1 


    1 00000000         ; Practical 4 Sample Solution
    2 00000000         ; (c) Mike Brady, 2020.
    3 00000000         
    4 00000000                 area             tcd,code,readonly
    5 00000000                 export           __main
    6 00000000         __main
    7 00000000         
    8 00000000         ; Definitions  -- references to 'UM' are to the User Man
                       ual.
    9 00000000         
   10 00000000         ; Timer Stuff -- UM, Table 173
   11 00000000         
   12 00000000 E0004000 
                       T0      equ              0xE0004000  ; Timer 0 Base Addr
                                                            ess
   13 00000000 E0008000 
                       T1      equ              0xE0008000
   14 00000000         
   15 00000000 00000000 
                       IR      equ              0           ; Add this to a tim
                                                            er's base address t
                                                            o get actual regist
                                                            er address
   16 00000000 00000004 
                       TCR     equ              4
   17 00000000 00000014 
                       MCR     equ              0x14
   18 00000000 00000018 
                       MR0     equ              0x18
   19 00000000         
   20 00000000 00000002 
                       TimerCommandReset
                               equ              2
   21 00000000 00000001 
                       TimerCommandRun
                               equ              1
   22 00000000 00000003 
                       TimerModeResetAndInterrupt
                               equ              3
   23 00000000 00000001 
                       TimerResetTimer0Interrupt
                               equ              1
   24 00000000 000000FF 
                       TimerResetAllInterrupts
                               equ              0xFF
   25 00000000         
   26 00000000         ; VIC Stuff -- UM, Table 41
   27 00000000 FFFFF000 
                       VIC     equ              0xFFFFF000  ; VIC Base Address
   28 00000000 00000010 
                       IntEnable
                               equ              0x10
   29 00000000 00000030 
                       VectAddr
                               equ              0x30
   30 00000000 00000100 
                       VectAddr0
                               equ              0x100
   31 00000000 00000200 



ARM Macro Assembler    Page 2 


                       VectCtrl0
                               equ              0x200
   32 00000000         
   33 00000000 00000004 
                       Timer0ChannelNumber
                               equ              4           ; UM, Table 63
   34 00000000 00000010 
                       Timer0Mask
                               equ              1<<Timer0ChannelNumber 
                                                            ; UM, Table 63
   35 00000000 00000005 
                       IRQslot_en
                               equ              5           ; UM, Table 58
   36 00000000         
   37 00000000         ; initialisation code
   38 00000000         
   39 00000000         ; Initialise the VIC
   40 00000000 E59F0230        ldr              r0,=VIC     ; looking at you, V
                                                            IC!
   41 00000004         
   42 00000004 E59F1230        ldr              r1,=irqhan
   43 00000008 E5801100        str              r1,[r0,#VectAddr0] ; associate 
                                                            our interrupt handl
                                                            er with Vectored In
                                                            terrupt 0
   44 0000000C         
   45 0000000C E3A01024        mov              r1,#Timer0ChannelNumber+(1<<IRQ
slot_en)
   46 00000010 E5801200        str              r1,[r0,#VectCtrl0] ; make Timer
                                                             0 interrupts the s
                                                            ource of Vectored I
                                                            nterrupt 0
   47 00000014         
   48 00000014 E3A01010        mov              r1,#Timer0Mask
   49 00000018 E5801010        str              r1,[r0,#IntEnable] ; enable Tim
                                                            er 0 interrupts to 
                                                            be recognised by th
                                                            e VIC
   50 0000001C         
   51 0000001C E3A01000        mov              r1,#0
   52 00000020 E5801030        str              r1,[r0,#VectAddr] ; remove any 
                                                            pending interrupt (
                                                            may not be needed)
   53 00000024         
   54 00000024         ; Initialise Timer 0
   55 00000024 E59F0214        ldr              r0,=T0      ; looking at you, T
                                                            imer 0!
   56 00000028         
   57 00000028 E3A01002        mov              r1,#TimerCommandReset
   58 0000002C E5801004        str              r1,[r0,#TCR]
   59 00000030         
   60 00000030 E3A010FF        mov              r1,#TimerResetAllInterrupts
   61 00000034 E5801000        str              r1,[r0,#IR]
   62 00000038         
   63 00000038         ;ldr r1,=(14745600/1600)-1  ; 626 us = 1/1600 second
   64 00000038 E3A01092        ldr              r1,=(14745600/100000)-1 
                                                            ; 1 second
   65 0000003C         
   66 0000003C E5801018        str              r1,[r0,#MR0]



ARM Macro Assembler    Page 3 


   67 00000040         
   68 00000040 E3A01003        mov              r1,#TimerModeResetAndInterrupt
   69 00000044 E5801014        str              r1,[r0,#MCR]
   70 00000048         
   71 00000048 E3A01001        mov              r1,#TimerCommandRun
   72 0000004C E5801004        str              r1,[r0,#TCR]
   73 00000050         
   74 00000050         ;from here, initialisation is finished, so it should be 
                       the main body of the main program
   75 00000050         
   76 00000050 E0028018 
                       IO1DIR  EQU              0xE0028018  ;
   77 00000050 E0028014 
                       IO1SET  EQU              0xE0028014  ;
   78 00000050 E002801C 
                       IO1CLR  EQU              0xE002801C  ;
   79 00000050         ;IO1PIN EQU 0xE0028010; as we have no inputs we are not 
                       considering PIN register
   80 00000050         
   81 00000050         
   82 00000050 E59F11EC        ldr              r1,=IO1DIR  ;
   83 00000054 E59F01EC        ldr              r0,=0x00f00f00 ;
   84 00000058 E5810000        str              r0,[r1]     ; making the pins 3
                                                            1-24 and 19-12 and 
                                                            7-0 outputs 
   85 0000005C E59F11E8        ldr              r1,=IO1SET  ;
   86 00000060 E5810000        str              r0,[r1]     ; set them to turn 
                                                            the LEDs off 
   87 00000064 E59F21E4        ldr              r2,=IO1CLR  ;
   88 00000068         
   89 00000068         LoopForever
   90 00000068         
   91 00000068 E59F61E4        ldr              r6,=InteruptBoolean ; loading t
                                                            he address of the i
                                                            nterupt boolean
   92 0000006C E5967000        ldr              r7,[r6]     ; 
   93 00000070 E3570001        cmp              r7,#1       ; checking till the
                                                             vaule of interupt 
                                                            boolean is 1
   94 00000074 1AFFFFFB        bne              LoopForever ;
   95 00000078         
   96 00000078 E59F41D8        ldr              r4,=secs0   ; loading address o
                                                            f secs[0]
   97 0000007C E59F51D8        ldr              r5,=secs1   ; loading address o
                                                            f secs[1]
   98 00000080 E5959000        ldr              r9,[r5]     ; loading the value
                                                             in secs[1]
   99 00000084 E3590009        cmp              r9,#9       ; if( secs[1] == 9)
                                                            
  100 00000088 1A000007        bne              secsUnder10 ; secs[0] += 1
  101 0000008C E5949000        ldr              r9,[r4]     ; 
  102 00000090 E2899001        add              r9,r9,#1    ; 
  103 00000094 E3590006        cmp              r9,#6       ; if( secs[0] == 6)
                                                            
  104 00000098 0A000006        beq              increaseMins ; increase minutes
                                                            , as max valid seco
                                                            nd is 59, we branch
                                                             to increase minute
                                                            s when it reaches 6



ARM Macro Assembler    Page 4 


                                                            0
  105 0000009C E5849000        str              r9,[r4]     ; storing increased
                                                             secs[0]
  106 000000A0 E3A09000        mov              r9,#0       ; and resetting sec
                                                            s[1] to zero as we 
                                                            have completed 10 i
                                                            ncrements and don't
                                                             want to
  107 000000A4 E5859000        str              r9,[r5]     ; have a hex value,
                                                             as we're looking f
                                                            or the BCD format
  108 000000A8 EA000047        b                updateTime  ; branch to update 
                                                            Time
  109 000000AC         
  110 000000AC         secsUnder10                          ; if( secs[1] < 9)
  111 000000AC E2899001        add              r9,r9,#1    ;  secs[1] += 1
  112 000000B0 E5859000        str              r9,[r5]     ; storing increased
                                                             secs[1]
  113 000000B4 EA000044        b                updateTime  ; branch to update 
                                                            Time 
  114 000000B8         
  115 000000B8         increaseMins                         ;
  116 000000B8 E59F4198        ldr              r4,=secs0   ; resetting seconds
                                                             to 00 as we have r
                                                            eached a minute and
                                                             increasing minutes
                                                             instead
  117 000000BC E3A09000        mov              r9,#0       ; resetting sec[0]
  118 000000C0 E5849000        str              r9,[r4]     ;
  119 000000C4         
  120 000000C4 E59F4190        ldr              r4,=secs1   ;
  121 000000C8 E3A09000        mov              r9,#0       ; resetting sec[1]
  122 000000CC E5849000        str              r9,[r4]     ;
  123 000000D0         
  124 000000D0 E59F4188        ldr              r4,=mins0   ; loading address o
                                                            f mins[0]
  125 000000D4 E59F5188        ldr              r5,=mins1   ; loading address o
                                                            f mins[1]
  126 000000D8 E5959000        ldr              r9,[r5]     ; if( mins[1] == 9)
                                                            
  127 000000DC E3590009        cmp              r9,#9       ; mins[0] += 1
  128 000000E0 1A000007        bne              minsUnder10 ;
  129 000000E4 E5949000        ldr              r9,[r4]     ;
  130 000000E8 E2899001        add              r9,r9,#1    ;
  131 000000EC E3590006        cmp              r9,#6       ; if( mins[0] == 6)
                                                            
  132 000000F0 0A000006        beq              increaseHrs ; increase hours, a
                                                            s max valid minute 
                                                            is 59, we branch to
                                                             increase hours whe
                                                            n it reaches 60
  133 000000F4 E5849000        str              r9,[r4]     ; storing increased
                                                             mins[0]
  134 000000F8 E3A09000        mov              r9,#0       ; and resetting min
                                                            s[1] to zero as we 
                                                            have completed 10 i
                                                            ncrements and don't
                                                             want to
  135 000000FC E5859000        str              r9,[r5]     ; have a hex value,



ARM Macro Assembler    Page 5 


                                                             as we're looking f
                                                            or the BCD format
  136 00000100 EA000031        b                updateTime  ; branch to update 
                                                            Time
  137 00000104         
  138 00000104         minsUnder10                          ; if( mins[1] < 9)
  139 00000104 E2899001        add              r9,r9,#1    ; mins[1] += 1
  140 00000108 E5859000        str              r9,[r5]     ; storing increased
                                                             mins[1] 
  141 0000010C EA00002E        b                updateTime  ; branch to update 
                                                            Time
  142 00000110         
  143 00000110         increaseHrs                          ; resetting seconds
                                                             to 00 and minutes 
                                                            to 00 as we have re
                                                            ached an hour and i
                                                            ncrease hours inste
                                                            ad
  144 00000110 E59F4140        ldr              r4,=secs0   ;
  145 00000114 E3A09000        mov              r9,#0       ; resetting sec[0]
  146 00000118 E5849000        str              r9,[r4]     ;
  147 0000011C E59F4138        ldr              r4,=secs1   ;
  148 00000120 E3A09000        mov              r9,#0       ; resetting sec[1]
  149 00000124 E5849000        str              r9,[r4]     ;
  150 00000128 E59F4130        ldr              r4,=mins0   ;
  151 0000012C E3A09000        mov              r9,#0       ; resetting min[0]
  152 00000130 E5849000        str              r9,[r4]     ;
  153 00000134 E59F4128        ldr              r4,=mins1   ;
  154 00000138 E3A09000        mov              r9,#0       ; resetting min[1]
  155 0000013C E5849000        str              r9,[r4]     ;
  156 00000140         
  157 00000140 E59F4120        ldr              r4,=hrs0    ; loading address o
                                                            f hrs[0]
  158 00000144 E59F5120        ldr              r5,=hrs1    ; loading address o
                                                            f hrs[1]
  159 00000148         
  160 00000148 E5959000        ldr              r9,[r5]     ; if( hrs[1] == 9)
  161 0000014C E3590009        cmp              r9,#9       ; hrs[0] += 1
  162 00000150 1A000007        bne              hrsUnder10  ;
  163 00000154 E5949000        ldr              r9,[r4]     ;
  164 00000158 E2899001        add              r9,r9,#1    ; if( hrs[0] == 10)
                                                            
  165 0000015C E359000A        cmp              r9,#10      ; reset time as we 
                                                            would end up with 9
                                                            9 hours
  166 00000160 0A000006        beq              ResetTime
  167 00000164 E5849000        str              r9,[r4]     ; storing increased
                                                             hrs[0]
  168 00000168 E3A09000        mov              r9,#0       ; and resetting hrs
                                                            [1] to zero as we h
                                                            ave completed 10 in
                                                            crements and don't 
                                                            want to
  169 0000016C E5859000        str              r9,[r5]     ; have a hex value,
                                                             as we're looking f
                                                            or the BCD format
  170 00000170 EA000015        b                updateTime  ; branch to update 
                                                            Time
  171 00000174         



ARM Macro Assembler    Page 6 


  172 00000174         hrsUnder10                           ; if( hrs[1] < 9)
  173 00000174 E2899001        add              r9,r9,#1    ; hrs[1] += 1
  174 00000178 E5859000        str              r9,[r5]     ; storing increased
                                                             Time
  175 0000017C         
  176 0000017C         ;ldr  r10,[r5]    ; loading hrs[1]
  177 0000017C         ;ldr  r9,[r4]     ; loading hrs[0]
  178 0000017C         ;orr  r10,r10,r9,lsl#4  ; using a mask and leftshifting 
                       to obtain 0x000000(hrs[0])(hrs[1])
  179 0000017C         ;cmp  r10,#0x00000024   ; if(hours == 24)
  180 0000017C         ;beq  ResetTime    ; branch to reset time
  181 0000017C         ; else
  182 0000017C EA000012        b                updateTime  ;  branch to update
                                                             Time 
  183 00000180         
  184 00000180         ResetTime                            ;
  185 00000180 E59F40D0        ldr              r4,=secs0   ;
  186 00000184 E3A09000        mov              r9,#0       ; resetting secs[0]
                                                             to 0
  187 00000188 E5849000        str              r9,[r4]     ;
  188 0000018C         
  189 0000018C E59F40C8        ldr              r4,=secs1   ;
  190 00000190 E3A09000        mov              r9,#0       ; resetting secs[1]
                                                             to 0
  191 00000194 E5849000        str              r9,[r4]     ;
  192 00000198         
  193 00000198 E59F40C0        ldr              r4,=mins0   ;
  194 0000019C E3A09000        mov              r9,#0       ; resetting mins[0]
                                                             to 0
  195 000001A0 E5849000        str              r9,[r4]     ;
  196 000001A4         
  197 000001A4 E59F40B8        ldr              r4,=mins1   ;
  198 000001A8 E3A09000        mov              r9,#0       ; resetting mins[1]
                                                             to 0
  199 000001AC E5849000        str              r9,[r4]     ;
  200 000001B0         
  201 000001B0 E59F40B0        ldr              r4,=hrs0    ;
  202 000001B4 E3A09000        mov              r9,#0       ; resetting hrs[0] 
                                                            to 0
  203 000001B8 E5849000        str              r9,[r4]     ;
  204 000001BC         
  205 000001BC E59F40A8        ldr              r4,=hrs1    ;
  206 000001C0 E3A09000        mov              r9,#0       ; resetting hrs[1] 
                                                            to 0
  207 000001C4 E5849000        str              r9,[r4]     ;
  208 000001C8         
  209 000001C8 EAFFFFFF        b                updateTime  ; branch to update 
                                                            Time 
  210 000001CC         
  211 000001CC         updateTime                           ;
  212 000001CC E59F1070        ldr              r1,=IO1DIR  ; Re-intialising th
                                                            e pins
  213 000001D0 E59F0070        ldr              r0,=0x00f00f00 ; Setting the pi
                                                            ns 31-24 and 19-12 
                                                            and 7-0
  214 000001D4 E5810000        str              r0,[r1]     ; Storing back to t
                                                            he DIR register
  215 000001D8         
  216 000001D8 E59F507C        ldr              r5,=secs1   ; Loading secs[1]



ARM Macro Assembler    Page 7 


  217 000001DC E5956000        ldr              r6,[r5]     ; format - hrs[0].h
                                                            rs[1] : mins[0].min
                                                            s[1] : secs[0].secs
                                                            [1]
  218 000001E0 E1A07006        mov              r7,r6, LSL#0 ; storing time in 
                                                            r7
  219 000001E4         
  220 000001E4 E59F506C        ldr              r5,=secs0   ; loading secs[0]
  221 000001E8 E5956000        ldr              r6,[r5]     ; using orr inorder
                                                             to not change prev
                                                            ious values while w
                                                            riting new values
  222 000001EC E1877206        orr              r7,r6, LSL#4 ; left shifting by
                                                             4 in order to fit 
                                                            secs[0] in our requ
                                                            ired format
  223 000001F0         
  224 000001F0 E59F506C        ldr              r5,=mins1   ; loading mins[1]
  225 000001F4 E5956000        ldr              r6,[r5]     ;
  226 000001F8 E1877606        orr              r7,r6, LSL#12 ; left shifting b
                                                            y 12 in order to fi
                                                            t mins[1] in our re
                                                            quired format
  227 000001FC         
  228 000001FC E59F505C        ldr              r5,=mins0   ; loading mins[0]
  229 00000200 E5956000        ldr              r6,[r5]     ;
  230 00000204 E1877806        orr              r7,r6, LSL#16 ; left shifting b
                                                            y 16 in order to fi
                                                            t mins[0] in our re
                                                            quired format
  231 00000208         
  232 00000208 E59F505C        ldr              r5,=hrs1    ; loading hrs[1]
  233 0000020C E5956000        ldr              r6,[r5]     ;
  234 00000210 E1877C06        orr              r7,r6, LSL#24 ; left shifting b
                                                            y 24 in order to fi
                                                            t hrs[1] in our req
                                                            uired format
  235 00000214         
  236 00000214 E59F504C        ldr              r5,=hrs0    ; loading hrs[0]
  237 00000218 E5956000        ldr              r6,[r5]     ;
  238 0000021C E1877E06        orr              r7,r6, LSL#28 ; left shifting b
                                                            y 28 in order to fi
                                                            t hrs[0] in our req
                                                            uired format
  239 00000220         
  240 00000220 E1877000        orr              r7,r7,r0    ; using #0x00f00f00
                                                             as a mask to get f
                                                             inplace of : as ou
                                                            r required format
  241 00000224         
  242 00000224 E5817000        str              r7,[r1]     ; writing our time 
                                                            in r7 to the DIR re
                                                            gister to display i
                                                            t on the GPIO0
  243 00000228         
  244 00000228 E59F6024        ldr              r6,=InteruptBoolean ; resetting
                                                             Interupt Boolean
  245 0000022C E3A07000        mov              r7,#0       ; setting it to zer
                                                            o



ARM Macro Assembler    Page 8 


  246 00000230 E5867000        str              r7,[r6]     ; so that it can be
                                                             set to 1 when ever
                                                             an interrupt occur
                                                            s
  247 00000234 EAFFFF8B        b                LoopForever ; braching back to 
                                                            LoopForever to loop
                                                             infinitely
  248 00000238         
  249 00000238 FFFFF000 
              00000000 
              E0004000 
              E0028018 
              00F00F00 
              E0028014 
              E002801C 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000         AREA             InterruptStuff, CODE, READONLY
  250 00000000 E24EE004 
                       irqhan  sub              lr,lr,#4
  251 00000004 E92D4003        stmfd            sp!,{r0-r1,lr} ; the lr will be
                                                             restored to the pc
                                                            
  252 00000008         
  253 00000008         ; the main purpose of the interrupt handler is merely to
                        update a tick counter
  254 00000008 E59F0020        ldr              r0,=InteruptBoolean ; loading t
                                                            he Interrupt Boolea
                                                            n from memory
  255 0000000C E3A01001        mov              r1,#1       ; 
  256 00000010 E5801000        str              r1,[r0]     ; setting the Inter
                                                            rupt Boolean to 1
  257 00000014         
  258 00000014         ;this is the body of the interrupt handler
  259 00000014         
  260 00000014         ;here you'd put the unique part of your interrupt handle



ARM Macro Assembler    Page 9 


                       r
  261 00000014         ;all the other stuff is "housekeeping" to save registers
                        and acknowledge interrupts
  262 00000014         
  263 00000014         
  264 00000014         ;this is where we stop the timer from making the interru
                       pt request to the VIC
  265 00000014         ;i.e. we 'acknowledge' the interrupt
  266 00000014 E59F0018        ldr              r0,=T0
  267 00000018 E3A01001        mov              r1,#TimerResetTimer0Interrupt
  268 0000001C E5801000        str              r1,[r0,#IR] ; remove MR0 interr
                                                            upt request from ti
                                                            mer
  269 00000020         
  270 00000020         ;here we stop the VIC from making the interrupt request 
                       to the CPU:
  271 00000020 E59F0010        ldr              r0,=VIC
  272 00000024 E3A01000        mov              r1,#0
  273 00000028 E5801030        str              r1,[r0,#VectAddr] ; reset VIC
  274 0000002C         
  275 0000002C E8FD8003        ldmfd            sp!,{r0-r1,pc}^ ; return from i
                                                            nterrupt, restoring
                                                             pc from lr
  276 00000030         ; and also restoring the CPSR
  277 00000030         
  278 00000030         ; TCD Read-Write Definitions.
  279 00000030         
  280 00000030 00000000 
              E0004000 
              FFFFF000         AREA             MutableDate, DATA, READWRITE
  281 00000000 00 00 00 
              00       InteruptBoolean
                               space            4
  282 00000004 00 00 00 
              00       hrs0    space            4
  283 00000008 00 00 00 
              00       hrs1    space            4
  284 0000000C 00 00 00 
              00       mins0   space            4
  285 00000010 00 00 00 
              00       mins1   space            4
  286 00000014 00 00 00 
              00       secs0   space            4
  287 00000018 00 00 00 
              00       secs1   space            4
  288 0000001C                 END
Command Line: --debug --diag_suppress=9931 --apcs=interwork --depend=.\objects\
tcd.d -o.\objects\tcd.o -I"C:\Users\th3j9\Desktop\Microprocessor Systems\ARM\RV
31\INC" -I"C:\Users\th3j9\Desktop\Microprocessor Systems\ARM\CMSIS\Include" -I"
C:\Users\th3j9\Desktop\Microprocessor Systems\ARM\INC\Philips" --predefine="__E
VAL SETA 1" --predefine="__UVISION_VERSION SETA 526" --list=.\listings\tcd.lst 
TCD.s
